"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[4812],{6761:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-1/rclpy-python-integration","title":"\ud83d\udc0d RCLPy Python Integration - Mastering ROS 2 with Python","description":"RCLPy (Robot Client Library for Python) is the Python client library for ROS 2. It provides the interface between your Python code and the ROS 2 middleware, enabling you to create nodes, publish/subscribe to topics, use services and actions, and manage the ROS 2 execution model. Mastering RCLPy is essential for Python-based robotic development.","source":"@site/docs/module-1/rclpy-python-integration.md","sourceDirName":"module-1","slug":"/module-1/rclpy-python-integration","permalink":"/https://github.com/Muhammad-Nawaz453/Physical-AI---Humanoid-Robotics-BOOK/ur/module-1/rclpy-python-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/Muhammad-Nawaz453/Physical-AI---Humanoid-Robotics/tree/main/docs/module-1/rclpy-python-integration.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"\ud83e\udd16 URDF Robot Description - Defining Your Robot\'s Physical Structure","permalink":"/https://github.com/Muhammad-Nawaz453/Physical-AI---Humanoid-Robotics-BOOK/ur/module-1/urdf-robot-description"},"next":{"title":"\ud83d\ude80 Launch Files - Orchestrating Your ROS 2 System","permalink":"/https://github.com/Muhammad-Nawaz453/Physical-AI---Humanoid-Robotics-BOOK/ur/module-1/launch-files"}}');var a=r(4848),s=r(8453);const i={sidebar_position:6},o="\ud83d\udc0d RCLPy Python Integration - Mastering ROS 2 with Python",l={},c=[{value:"\ud83c\udfaf Learning Objectives",id:"-learning-objectives",level:2},{value:"\ud83c\udfd7\ufe0f Understanding RCLPy Architecture",id:"\ufe0f-understanding-rclpy-architecture",level:2},{value:"Core RCLPy Components",id:"core-rclpy-components",level:3},{value:"\ud83d\udd27 Advanced Node Patterns",id:"-advanced-node-patterns",level:2},{value:"Parameter Handling",id:"parameter-handling",level:3},{value:"Multi-threaded Execution",id:"multi-threaded-execution",level:3},{value:"\ud83c\udfaf Complex Communication Patterns",id:"-complex-communication-patterns",level:2},{value:"State Machine Node",id:"state-machine-node",level:3},{value:"\ud83d\udd0d RCLPy Utilities and Debugging",id:"-rclpy-utilities-and-debugging",level:2},{value:"Lifecycle Node Implementation",id:"lifecycle-node-implementation",level:3},{value:"Testing with RCLPy",id:"testing-with-rclpy",level:3},{value:"\ud83e\uddea Hands-On Exercise: Autonomous Patrol Robot",id:"-hands-on-exercise-autonomous-patrol-robot",level:2},{value:"\ud83d\udca1 Key Takeaways",id:"-key-takeaways",level:2},{value:"\ud83d\udcda Further Reading",id:"-further-reading",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"-rclpy-python-integration---mastering-ros-2-with-python",children:"\ud83d\udc0d RCLPy Python Integration - Mastering ROS 2 with Python"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"RCLPy"})," (Robot Client Library for Python) is the Python client library for ROS 2. It provides the interface between your Python code and the ROS 2 middleware, enabling you to create nodes, publish/subscribe to topics, use services and actions, and manage the ROS 2 execution model. Mastering RCLPy is essential for Python-based robotic development."]}),"\n",(0,a.jsx)(n.h2,{id:"-learning-objectives",children:"\ud83c\udfaf Learning Objectives"}),"\n",(0,a.jsx)(n.p,{children:"By the end of this chapter, you will:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Understand the core concepts and architecture of RCLPy"}),"\n",(0,a.jsx)(n.li,{children:"Create complex ROS 2 nodes with multiple communication patterns"}),"\n",(0,a.jsx)(n.li,{children:"Implement parameter handling and dynamic reconfiguration"}),"\n",(0,a.jsx)(n.li,{children:"Use RCLPy utilities for debugging and testing"}),"\n",(0,a.jsx)(n.li,{children:"Build production-ready Python ROS 2 applications"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"\ufe0f-understanding-rclpy-architecture",children:"\ud83c\udfd7\ufe0f Understanding RCLPy Architecture"}),"\n",(0,a.jsx)(n.p,{children:"RCLPy serves as the Python binding for the ROS Client Library (RCL), which sits on top of the ROS middleware (RMW). This layered architecture provides:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Abstraction"}),": Hides low-level middleware details"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Performance"}),": Leverages C++ implementations for critical operations"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Flexibility"}),": Supports multiple middleware implementations (Fast DDS, Cyclone DDS, etc.)"]}),"\n"]}),"\n",(0,a.jsx)(n.admonition,{title:"Did You Know?",type:"info",children:(0,a.jsx)(n.p,{children:"RCLPy follows the same node lifecycle as other ROS 2 client libraries, ensuring consistent behavior across languages."})}),"\n",(0,a.jsx)(n.h3,{id:"core-rclpy-components",children:"Core RCLPy Components"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom rclpy.qos import QoSProfile\r\nfrom rclpy.parameter import Parameter\r\n\r\n# Basic initialization pattern\r\ndef main(args=None):\r\n    # Initialize the ROS 2 communication\r\n    rclpy.init(args=args)\r\n\r\n    # Create your node\r\n    my_node = MyNode()\r\n\r\n    # Spin to process callbacks\r\n    try:\r\n        rclpy.spin(my_node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        # Cleanup\r\n        my_node.destroy_node()\r\n        rclpy.shutdown()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"-advanced-node-patterns",children:"\ud83d\udd27 Advanced Node Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"parameter-handling",children:"Parameter Handling"}),"\n",(0,a.jsx)(n.p,{children:"Parameters allow runtime configuration of nodes without recompilation:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# parameter_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.parameter import Parameter\r\n\r\nclass ParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('parameter_node')\r\n\r\n        # Declare parameters with default values and descriptions\r\n        self.declare_parameter('robot_name', 'turtlebot4')\r\n        self.declare_parameter('max_velocity', 0.5)\r\n        self.declare_parameter('safety_distance', 0.3)\r\n        self.declare_parameter('debug_mode', False)\r\n\r\n        # Access parameter values\r\n        self.robot_name = self.get_parameter('robot_name').value\r\n        self.max_velocity = self.get_parameter('max_velocity').value\r\n        self.safety_distance = self.get_parameter('safety_distance').value\r\n        self.debug_mode = self.get_parameter('debug_mode').value\r\n\r\n        # Set up parameter callback for dynamic reconfiguration\r\n        self.add_on_set_parameters_callback(self.parameter_callback)\r\n\r\n        self.get_logger().info(f'Node initialized for robot: {self.robot_name}')\r\n\r\n    def parameter_callback(self, params):\r\n        \"\"\"Handle parameter changes at runtime\"\"\"\r\n        for param in params:\r\n            if param.name == 'max_velocity' and param.type_ == Parameter.Type.DOUBLE:\r\n                if 0.0 <= param.value <= 2.0:  # Validate range\r\n                    self.max_velocity = param.value\r\n                    self.get_logger().info(f'Max velocity updated to: {param.value}')\r\n                else:\r\n                    self.get_logger().warn(f'Invalid velocity value: {param.value}')\r\n                    return rclpy.node.SetParametersResult(successful=False)\r\n            elif param.name == 'debug_mode':\r\n                self.debug_mode = param.value\r\n                status = 'enabled' if param.value else 'disabled'\r\n                self.get_logger().info(f'Debug mode {status}')\r\n\r\n        return rclpy.node.SetParametersResult(successful=True)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = ParameterNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"multi-threaded-execution",children:"Multi-threaded Execution"}),"\n",(0,a.jsx)(n.p,{children:"For complex nodes that need to handle multiple tasks simultaneously:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# multi_threaded_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\r\nfrom std_msgs.msg import String\r\nimport threading\r\nimport time\r\n\r\nclass MultiThreadedNode(Node):\r\n    def __init__(self):\r\n        super().__init__('multi_threaded_node')\r\n\r\n        # Create callback groups for thread separation\r\n        self.group1 = MutuallyExclusiveCallbackGroup()\r\n        self.group2 = MutuallyExclusiveCallbackGroup()\r\n\r\n        # Publishers\r\n        self.pub1 = self.create_publisher(String, 'topic1', 10)\r\n        self.pub2 = self.create_publisher(String, 'topic2', 10)\r\n\r\n        # Subscriptions\r\n        self.sub1 = self.create_subscription(\r\n            String, 'input1', self.callback1, 10,\r\n            callback_group=self.group1\r\n        )\r\n        self.sub2 = self.create_subscription(\r\n            String, 'input2', self.callback2, 10,\r\n            callback_group=self.group2\r\n        )\r\n\r\n        # Timers\r\n        self.timer1 = self.create_timer(\r\n            1.0, self.timer1_callback,\r\n            callback_group=self.group1\r\n        )\r\n        self.timer2 = self.create_timer(\r\n            2.0, self.timer2_callback,\r\n            callback_group=self.group2\r\n        )\r\n\r\n        self.get_logger().info('Multi-threaded node initialized')\r\n\r\n    def callback1(self, msg):\r\n        self.get_logger().info(f'Callback 1 received: {msg.data}')\r\n        # Simulate processing time\r\n        time.sleep(0.1)\r\n\r\n    def callback2(self, msg):\r\n        self.get_logger().info(f'Callback 2 received: {msg.data}')\r\n        # Simulate processing time\r\n        time.sleep(0.1)\r\n\r\n    def timer1_callback(self):\r\n        msg = String()\r\n        msg.data = f'Timer 1: {self.get_clock().now().nanoseconds}'\r\n        self.pub1.publish(msg)\r\n\r\n    def timer2_callback(self):\r\n        msg = String()\r\n        msg.data = f'Timer 2: {self.get_clock().now().nanoseconds}'\r\n        self.pub2.publish(msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    # Use multi-threaded executor\r\n    executor = MultiThreadedExecutor(num_threads=4)\r\n\r\n    node = MultiThreadedNode()\r\n    executor.add_node(node)\r\n\r\n    try:\r\n        executor.spin()\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"-complex-communication-patterns",children:"\ud83c\udfaf Complex Communication Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"state-machine-node",children:"State Machine Node"}),"\n",(0,a.jsx)(n.p,{children:"Implementing a state machine pattern for complex robotic behaviors:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# state_machine_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Twist\r\nfrom enum import Enum\r\nimport time\r\n\r\nclass RobotState(Enum):\r\n    IDLE = 1\r\n    NAVIGATING = 2\r\n    MANIPULATING = 3\r\n    EMERGENCY_STOP = 4\r\n\r\nclass StateMachineNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'state_machine_node\')\r\n\r\n        # State management\r\n        self.current_state = RobotState.IDLE\r\n        self.previous_state = None\r\n\r\n        # Publishers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'cmd_vel\', 10)\r\n        self.state_pub = self.create_publisher(String, \'robot_state\', 10)\r\n\r\n        # Subscriptions\r\n        self.command_sub = self.create_subscription(\r\n            String, \'command\', self.command_callback, 10\r\n        )\r\n\r\n        # Timer for state processing\r\n        self.state_timer = self.create_timer(0.1, self.state_machine_callback)\r\n\r\n        # State-specific data\r\n        self.navigation_goal = None\r\n        self.manipulation_task = None\r\n\r\n        self.get_logger().info(\'State machine node initialized\')\r\n\r\n    def command_callback(self, msg):\r\n        """Handle incoming commands"""\r\n        command = msg.data.lower()\r\n\r\n        if command == \'navigate\':\r\n            if self.current_state == RobotState.IDLE:\r\n                self.current_state = RobotState.NAVIGATING\r\n                self.navigation_goal = (1.0, 1.0)  # Example goal\r\n                self.get_logger().info(\'Transitioning to NAVIGATING state\')\r\n\r\n        elif command == \'manipulate\':\r\n            if self.current_state == RobotState.IDLE:\r\n                self.current_state = RobotState.MANIPULATING\r\n                self.manipulation_task = \'pick_object\'\r\n                self.get_logger().info(\'Transitioning to MANIPULATING state\')\r\n\r\n        elif command == \'stop\':\r\n            self.current_state = RobotState.IDLE\r\n            self.get_logger().info(\'Transitioning to IDLE state\')\r\n\r\n        elif command == \'emergency_stop\':\r\n            self.current_state = RobotState.EMERGENCY_STOP\r\n            self.emergency_stop()\r\n            self.get_logger().warn(\'EMERGENCY STOP ACTIVATED\')\r\n\r\n    def state_machine_callback(self):\r\n        """Main state machine processing"""\r\n        if self.current_state != self.previous_state:\r\n            self.handle_state_transition()\r\n            self.previous_state = self.current_state\r\n\r\n        # Process current state\r\n        if self.current_state == RobotState.IDLE:\r\n            self.process_idle_state()\r\n        elif self.current_state == RobotState.NAVIGATING:\r\n            self.process_navigating_state()\r\n        elif self.current_state == RobotState.MANIPULATING:\r\n            self.process_manipulating_state()\r\n        elif self.current_state == RobotState.EMERGENCY_STOP:\r\n            self.process_emergency_stop_state()\r\n\r\n        # Publish current state\r\n        state_msg = String()\r\n        state_msg.data = self.current_state.name\r\n        self.state_pub.publish(state_msg)\r\n\r\n    def handle_state_transition(self):\r\n        """Handle actions when entering a new state"""\r\n        if self.current_state == RobotState.IDLE:\r\n            # Stop all motion when entering IDLE\r\n            self.stop_motion()\r\n        elif self.current_state == RobotState.EMERGENCY_STOP:\r\n            self.emergency_stop()\r\n\r\n    def process_idle_state(self):\r\n        """Process IDLE state"""\r\n        # Robot is stationary, ready for commands\r\n        self.stop_motion()\r\n\r\n    def process_navigating_state(self):\r\n        """Process NAVIGATING state"""\r\n        if self.navigation_goal:\r\n            # Simple navigation logic (in real implementation, use Nav2)\r\n            current_pos = (0.0, 0.0)  # Get actual position\r\n            goal = self.navigation_goal\r\n\r\n            # Calculate velocity command\r\n            dx = goal[0] - current_pos[0]\r\n            dy = goal[1] - current_pos[1]\r\n\r\n            if abs(dx) < 0.1 and abs(dy) < 0.1:\r\n                # Reached goal\r\n                self.current_state = RobotState.IDLE\r\n                self.get_logger().info(\'Navigation goal reached\')\r\n            else:\r\n                # Move towards goal\r\n                cmd = Twist()\r\n                cmd.linear.x = min(0.5, max(-0.5, dx * 0.5))\r\n                cmd.linear.y = min(0.5, max(-0.5, dy * 0.5))\r\n                self.cmd_vel_pub.publish(cmd)\r\n\r\n    def process_manipulating_state(self):\r\n        """Process MANIPULATING state"""\r\n        if self.manipulation_task == \'pick_object\':\r\n            # Simulate manipulation\r\n            self.get_logger().info(\'Executing manipulation task...\')\r\n            # In real implementation, control manipulator joints\r\n            time.sleep(0.1)  # Simulate work\r\n\r\n    def process_emergency_stop_state(self):\r\n        """Process EMERGENCY_STOP state"""\r\n        self.emergency_stop()\r\n\r\n    def stop_motion(self):\r\n        """Stop all robot motion"""\r\n        cmd = Twist()\r\n        cmd.linear.x = 0.0\r\n        cmd.linear.y = 0.0\r\n        cmd.linear.z = 0.0\r\n        cmd.angular.x = 0.0\r\n        cmd.angular.y = 0.0\r\n        cmd.angular.z = 0.0\r\n        self.cmd_vel_pub.publish(cmd)\r\n\r\n    def emergency_stop(self):\r\n        """Immediate stop with safety measures"""\r\n        self.stop_motion()\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = StateMachineNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"-rclpy-utilities-and-debugging",children:"\ud83d\udd0d RCLPy Utilities and Debugging"}),"\n",(0,a.jsx)(n.h3,{id:"lifecycle-node-implementation",children:"Lifecycle Node Implementation"}),"\n",(0,a.jsx)(n.p,{children:"For production systems, lifecycle nodes provide better resource management:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'# lifecycle_node.py\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom rclpy.lifecycle import LifecycleNode, LifecycleState, TransitionCallbackReturn\r\nfrom rclpy.lifecycle import Publisher\r\nfrom std_msgs.msg import String\r\n\r\nclass LifecycleExampleNode(LifecycleNode):\r\n    def __init__(self):\r\n        super().__init__(\'lifecycle_example_node\')\r\n        self.get_logger().info(\'Lifecycle node created, current state: unconfigured\')\r\n\r\n    def on_configure(self, state: LifecycleState) -> TransitionCallbackReturn:\r\n        """Called when transitioning to configuring state"""\r\n        self.get_logger().info(\'Configuring node...\')\r\n\r\n        # Create publishers/subscribers (but not active yet)\r\n        self.pub = self.create_publisher(String, \'lifecycle_topic\', 10)\r\n\r\n        # Configure parameters\r\n        self.declare_parameter(\'publish_rate\', 1.0)\r\n\r\n        self.get_logger().info(\'Node configured\')\r\n        return TransitionCallbackReturn.SUCCESS\r\n\r\n    def on_activate(self, state: LifecycleState) -> TransitionCallbackReturn:\r\n        """Called when transitioning to activating state"""\r\n        self.get_logger().info(\'Activating node...\')\r\n\r\n        # Activate publishers/subscribers\r\n        self.pub.activate()\r\n\r\n        # Create timer\r\n        self.timer = self.create_timer(\r\n            1.0 / self.get_parameter(\'publish_rate\').value,\r\n            self.timer_callback\r\n        )\r\n\r\n        self.get_logger().info(\'Node activated\')\r\n        return TransitionCallbackReturn.SUCCESS\r\n\r\n    def on_deactivate(self, state: LifecycleState) -> TransitionCallbackReturn:\r\n        """Called when transitioning to deactivating state"""\r\n        self.get_logger().info(\'Deactivating node...\')\r\n\r\n        # Deactivate publishers/subscribers\r\n        self.pub.deactivate()\r\n\r\n        # Destroy timer\r\n        self.timer.destroy()\r\n\r\n        self.get_logger().info(\'Node deactivated\')\r\n        return TransitionCallbackReturn.SUCCESS\r\n\r\n    def on_cleanup(self, state: LifecycleState) -> TransitionCallbackReturn:\r\n        """Called when transitioning to cleaningup state"""\r\n        self.get_logger().info(\'Cleaning up node...\')\r\n\r\n        # Destroy publishers/subscribers\r\n        self.destroy_publisher(self.pub)\r\n\r\n        self.get_logger().info(\'Node cleaned up\')\r\n        return TransitionCallbackReturn.SUCCESS\r\n\r\n    def on_shutdown(self, state: LifecycleState) -> TransitionCallbackReturn:\r\n        """Called when transitioning to shuttingdown state"""\r\n        self.get_logger().info(\'Shutting down node...\')\r\n        return TransitionCallbackReturn.SUCCESS\r\n\r\n    def timer_callback(self):\r\n        """Timer callback for publishing messages"""\r\n        msg = String()\r\n        msg.data = f\'Lifecycle message: {self.get_clock().now().nanoseconds}\'\r\n        self.pub.publish(msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = LifecycleExampleNode()\r\n\r\n    # Initially configure the node\r\n    node.configure()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(n.h3,{id:"testing-with-rclpy",children:"Testing with RCLPy"}),"\n",(0,a.jsx)(n.p,{children:"Creating unit tests for your ROS 2 nodes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"# test_robot_node.py\r\nimport unittest\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\nfrom geometry_msgs.msg import Twist\r\nimport threading\r\nimport time\r\n\r\nclass TestRobotNode(unittest.TestCase):\r\n    def setUp(self):\r\n        rclpy.init()\r\n        self.node = RobotTestNode()\r\n\r\n        # Start spinning in a separate thread\r\n        self.executor = rclpy.executors.SingleThreadedExecutor()\r\n        self.executor.add_node(self.node)\r\n\r\n        self.spin_thread = threading.Thread(target=self.executor.spin)\r\n        self.spin_thread.start()\r\n\r\n    def tearDown(self):\r\n        self.executor.shutdown()\r\n        self.node.destroy_node()\r\n        rclpy.shutdown()\r\n        self.spin_thread.join()\r\n\r\n    def test_node_initialization(self):\r\n        \"\"\"Test that node initializes correctly\"\"\"\r\n        self.assertIsNotNone(self.node)\r\n        self.assertEqual(self.node.get_name(), 'robot_test_node')\r\n\r\n    def test_publisher_exists(self):\r\n        \"\"\"Test that required publishers exist\"\"\"\r\n        self.assertTrue(hasattr(self.node, 'cmd_vel_pub'))\r\n        self.assertIsNotNone(self.node.cmd_vel_pub)\r\n\r\n    def test_parameter_validation(self):\r\n        \"\"\"Test parameter handling\"\"\"\r\n        # Test default parameter values\r\n        self.assertEqual(self.node.get_parameter('robot_name').value, 'turtlebot4')\r\n\r\n        # Test parameter setting\r\n        self.node.set_parameters([rclpy.parameter.Parameter('robot_name', value='new_robot')])\r\n        self.assertEqual(self.node.get_parameter('robot_name').value, 'new_robot')\r\n\r\nclass RobotTestNode(Node):\r\n    def __init__(self):\r\n        super().__init__('robot_test_node')\r\n        self.declare_parameter('robot_name', 'turtlebot4')\r\n        self.cmd_vel_pub = self.create_publisher(Twist, 'cmd_vel', 10)\r\n\r\nif __name__ == '__main__':\r\n    unittest.main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"-hands-on-exercise-autonomous-patrol-robot",children:"\ud83e\uddea Hands-On Exercise: Autonomous Patrol Robot"}),"\n",(0,a.jsx)(n.p,{children:"Create an autonomous patrol robot node with the following requirements:"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Expected Time:"})," 40 minutes"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Requirements:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"State machine with patrol, return-to-base, and emergency states"}),"\n",(0,a.jsx)(n.li,{children:"Parameter configuration for patrol route"}),"\n",(0,a.jsx)(n.li,{children:"Publisher for robot position"}),"\n",(0,a.jsx)(n.li,{children:"Service for changing patrol route"}),"\n",(0,a.jsx)(n.li,{children:"Action client for navigation"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Instructions:"})}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Implement a state machine with patrol, return-to-base, and emergency states"}),"\n",(0,a.jsx)(n.li,{children:"Use parameters to configure patrol route waypoints"}),"\n",(0,a.jsx)(n.li,{children:"Create a service to update patrol route at runtime"}),"\n",(0,a.jsx)(n.li,{children:"Implement position publishing at regular intervals"}),"\n",(0,a.jsx)(n.li,{children:"Add emergency stop functionality"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Solution Hints:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Use a timer to periodically check for state transitions"}),"\n",(0,a.jsx)(n.li,{children:"Store patrol route as a parameter array"}),"\n",(0,a.jsx)(n.li,{children:"Consider using the navigation action client for movement"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"-key-takeaways",children:"\ud83d\udca1 Key Takeaways"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"RCLPy"})," provides Python access to all ROS 2 features with efficient C++ backend"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Parameters"})," enable runtime configuration without recompilation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Callback groups"})," allow thread-safe execution of different node components"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Lifecycle nodes"})," provide better resource management for production systems"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"State machines"})," are powerful patterns for complex robotic behaviors"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"-further-reading",children:"\ud83d\udcda Further Reading"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/p/rclpy/",children:"RCLPy Documentation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/Tutorials/Beginner-Client-Libraries/Creating-Your-First-ROS2-Package.html",children:"ROS 2 Python Tutorials"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://docs.ros.org/en/rolling/How-To-Guides/Using-Parameters-in-a-class-CPP.html",children:"ROS 2 Parameter System"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"Next Chapter:"})," ",(0,a.jsx)(n.a,{href:"/module-1/launch-files",children:"Launch Files"})]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const a={},s=t.createContext(a);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);